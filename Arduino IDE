#include <SoftwareSerial.h>
#include <ModbusMaster.h>

// ================== PIN SETUP (NodeMCU) ==================
#define RS485_RX   D6   // GPIO12  (RO -> RX)
#define RS485_TX   D5   // GPIO14  (DI -> TX)
#define RS485_DE   D1   // GPIO5   (DE & RE digabung)

// ================== MODBUS SETUP ==================
#define SLAVE_ID   1
#define BAUDRATE   9600

SoftwareSerial rs485(RS485_RX, RS485_TX);  // RX, TX
ModbusMaster node;

// ================== PARAMETER YANG SERING DIGANTI ==================
// 1=Coils, 2=Discrete Inputs, 3=Holding Reg, 4=Input Reg
uint8_t  READ_FUNCTION = 3;

// Address tool: 40001/30001 dll -> di kode biasanya (address-1)
uint16_t START_ADDRESS = 0;

// Quantity:
uint8_t  QUANTITY = 2;

// 1=INT16, 2=UINT16, 3=FLOAT32 AB, 4=FLOAT32 BA
uint8_t  DATA_TYPE = 1;

// ============== TX Enable control (DE/RE) ==============
void preTransmission() {
  digitalWrite(RS485_DE, HIGH);   // transmit mode
}

void postTransmission() {
  digitalWrite(RS485_DE, LOW);    // receive mode
}

// ================== SETUP ==================
void setup() {
  Serial.begin(9600);
  delay(200);

  pinMode(RS485_DE, OUTPUT);
  digitalWrite(RS485_DE, LOW); // default receive

  rs485.begin(BAUDRATE);

  node.begin(SLAVE_ID, rs485);
  node.preTransmission(preTransmission);
  node.postTransmission(postTransmission);

  Serial.println("ESP8266 Modbus RTU - Read Only Ready");
}

// ================== PRINT DATA ==================
void printData() {

  if (DATA_TYPE == 1) { // INT16

    for (uint8_t i = 0; i < QUANTITY; i++) {
      int16_t v = (int16_t)node.getResponseBuffer(i);
      Serial.print("INT16 [");
      Serial.print(i);
      Serial.print("]: ");
      Serial.println(v);
    }

  }

  else if (DATA_TYPE == 2) { // UINT16

    for (uint8_t i = 0; i < QUANTITY; i++) {
      uint16_t v = (uint16_t)node.getResponseBuffer(i);
      Serial.print("UINT16 [");
      Serial.print(i);
      Serial.print("]: ");
      Serial.println(v);
    }

  }

  else if (DATA_TYPE == 3 && QUANTITY >= 2) { // FLOAT32 AB

    uint32_t raw = ((uint32_t)node.getResponseBuffer(0) << 16) |
                    (uint32_t)node.getResponseBuffer(1);
    float f;
    memcpy(&f, &raw, 4);
    Serial.print("FLOAT32 AB: ");
    Serial.println(f);

  }

  else if (DATA_TYPE == 4 && QUANTITY >= 2) { // FLOAT32 BA

    uint32_t raw = ((uint32_t)node.getResponseBuffer(1) << 16) |
                    (uint32_t)node.getResponseBuffer(0);
    float f;
    memcpy(&f, &raw, 4);
    Serial.print("FLOAT32 BA: ");
    Serial.println(f);

  }

  else {
    Serial.println("Unknown DATA_TYPE or QUANTITY");
  }
}

// ================== LOOP ==================
void loop() {
  uint8_t result = 0xFF;

  // ===== pilih function read =====
  if (READ_FUNCTION == 1) {
    result = node.readCoils(START_ADDRESS, QUANTITY);
  } else if (READ_FUNCTION == 2) {
    result = node.readDiscreteInputs(START_ADDRESS, QUANTITY);
  } else if (READ_FUNCTION == 3) {
    result = node.readHoldingRegisters(START_ADDRESS, QUANTITY);
  } else if (READ_FUNCTION == 4) {
    result = node.readInputRegisters(START_ADDRESS, QUANTITY);
  } else {
    Serial.println("Wrong READ_FUNCTION");
    delay(1000);
    return;
  }

  // ===== cek hasil =====
  if (result != node.ku8MBSuccess) {
    Serial.print("Modbus Error: ");
    Serial.println(result);
    delay(1000);
    return;
  }

  // ===== tampilkan =====
  printData();
  node.clearResponseBuffer();

  delay(1000);
}
